- [Lec04 Page tables](#lec04-page-tables)
  - [Page table](#page-table)
  - [页表缓存（Translation Lookaside Buffer）](#页表缓存translation-lookaside-buffer)
  - [Kernel Page Table](#kernel-page-table)
  - [Code](#code)
- [Lec05 Calling conventions and stack frames RISC-V (TA)(感觉没啥用这一节)](#lec05-calling-conventions-and-stack-frames-risc-v-ta感觉没啥用这一节)
  - [Stack](#stack)
- [Lec06 Isolation \& system call entry/exit (Robert)](#lec06-isolation--system-call-entryexit-robert)
  - [Trap机制](#trap机制)
  - [syscall Trap代码执行流程](#syscall-trap代码执行流程)
  - [Traps from kernel space](#traps-from-kernel-space)
- [Page faults](#page-faults)
  - [Page Faults Basics](#page-faults-basics)
  - [Lazy Page allocation](#lazy-page-allocation)
  - [Zero Fill On Demand](#zero-fill-on-demand)
  - [Copy on Write Fork](#copy-on-write-fork)
  - [Demand Paging](#demand-paging)
  - [Memory Mapped Files](#memory-mapped-files)

# Lec04 Page tables

## Page table

内存管理单元（MMU，，emory Management Unit）将虚拟地址（virtual address简称va）翻译为物理内存（简称pa）。mmu有表单，保存在内存中，mmu访问内存完成翻译。
不为每一个地址创建一个表单条目，而是为每个页创建一个表单，每次翻译针对一个page，xv6中规定一个页4096字节，也就是2^12字节。
xv6的page table分为三级页表，虚拟地址39位，低12位是offset，对应page大小，实际上用来索引在page中的位置。中间的27位是三级index，剩下的高25位无效。使用高9位索引第一级page directory，directory的一个条目成为PTE(page table entry)，9位用来索引，因此一个directory page有512个条目。每个pte共使用54bits，低10bits是flag，44bits的物理页号（ppn）。高级page directory中的ppn指向低级page directory，最低一级的ppn加上va的offset构成pa。
使用三级页表的好处是节省空间，如果一个进程只是用了一个page，如果不使用三级页表，就需要2^27个pte，现在，只需要1级页表，第0个pte指向二级，二级第0个指向三级，共3*512个条目。
最高级的表单的地址存储在satp寄存器中，切换进程时需要切换satp中的内容，每个进程对应的satp由内核保存。
高级page directory中的44bits ppn，低12bits填0，得到下一级page directory的物理地址。最后一级加上offset得到pa。
每个pte低10bits是flags，包括V，是否有效，如上述例子只使用1个page，那么第一级页表的第0个pte的v置为1其他为0。其他还有r、w、u等。**注意，这些flag声明的是对应的page的权限，而不是pte自己的**
如果pte指向物理地址，那么v和其他权限为如r、w、x等会被设置，指向下一级只设置v。因此可以使用`if ((pte & (PTE_R | PTE_W | PTE_X)) == 0)`判断是否是最后一级页表。

## 页表缓存（Translation Lookaside Buffer）

加载存储数据需要三次访问内存，速度较慢，因此有TLB。第一次访问得到va到pa的映射后存储在tlb中。切换进程需要切换page table，os告诉cpu，tlb不能用了。

## Kernel Page Table

xv6中，在完成了虚拟到物理地址的翻译之后，如果得到的物理地址大于0x80000000会走向DRAM芯片，如果得到的物理地址低于0x80000000会走向不同的I/O设备。地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。cpu中有一个多路选择器来选择指令是走内存还是哪个硬件。
内核的虚拟地址，xv6采用直接映射，即va和pa相同。kernel stack在va中很靠后，在它下面有未映射的Guard page，对应的flag v未设置，防止stack越界，越界报错。kernel stack被映射了两次，在靠后的虚拟地址映射了一次，在PHYSTOP下的Kernel data中又映射了一次，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。
![alt text](images/image.png)
每个进程有一个对应的stack。XV6使用这段free memory来存放用户进程的page table，text和data。如果我们运行了非常多的用户进程，某个时间点我们会耗尽这段内存，这个时候fork或者exec会返回错误。当kernel创建了一个进程，针对这个进程的page table也会从Free memory中分配出来。内核会为用户进程的page table分配几个page，并填入PTE。在某个时间点，当内核运行了这个进程，内核会将进程的根page table的地址加载到SATP中。从那个时间点开始，处理器会使用内核为那个进程构建的虚拟地址空间。
本质上来说the size of kernel va space is same as user's.

## Code

查看main函数，调用的一个函数是kvminit，这个函数会设置好kernel的地址空间。
之后，kvminit函数返回了，在main函数中，我们运行到了kvminithart函数。

```c
void
kvminithart()
{
  w_satp(MAKE_SATP(kernel_pagetable));
  sfence_vma();
}
```

设置了SATP寄存器，kernel_pagetable变量来自于kvminit第一行。所以这里实际上是内核告诉MMU来使用刚刚设置好的page table。在这条指令之前，还不存在可用的page table，所以也就不存在地址翻译。执行完这条指令之后，程序计数器（Program Counter）增加了4。而之后的下一条指令被执行时，程序计数器会被内存中的page table翻译。

# Lec05 Calling conventions and stack frames RISC-V (TA)(感觉没啥用这一节)

## Stack

![alt text](images/image-1.png)
每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长
一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。因此Stack Frame不是一样大的，但是可以确定，开始的一定是return address和to prev. Framp。
有关StackFrame有两个寄存器，一个SP，一个Fp。Sp直线现在的栈帧位置，Fp指向当前栈帧的顶部（用于访问return address and pre framp）。

# Lec06 Isolation & system call entry/exit (Robert)

## Trap机制

用户空间和内核空间切换叫trap。共三种：

- 用户程序系统调用。
- 程序发生异常，如缺页、除0.
- 设备中断需要内核驱动程序。

重点是用户的32个寄存器。其中包括一些很有趣的register，这些寄存器表明系统调用执行时的系统状态。

- 在硬件中还有一个寄存器叫做程序计数器（Program Counter Register）。
- 表明当前mode的标志位，这个标志位表明了当前是supervisor mode还是user mode。
- 还有一堆控制CPU工作方式的寄存器，比如SATP（Supervisor Address Translation and Protection）寄存器，它包含了指向page table的物理内存地址。
- 还有一些对于今天讨论非常重要的寄存器，比如STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中处理trap的指令的起始地址。
- stvec：trap handler的地址，由kernel写入
- sepc：保存trap发生时的现场program counter，因为接下来pc要被取代为stvec。sret是从trap回到现场的指令，将sepc写回到pc
- scause：一个trap产生的原因代码，由CPU写入
- sscratch：放在trap handler的最开始处
- sstatus：控制设备中断是否被开启，如果sstatus中的SIE位被清除，则RISC-V将推迟设备中断。SPP位指示这个trap是在user space中产生的还是在kernel space产生的，并将控制sret回到什么模式
- 以上寄存器只在supervisor模式下发生的trap被使用

当发生除了计时器中断以外的其他类型的trap时，RISC-V将执行以下步骤：

- 如果trap是一个设备产生的中断，而SIE又被清除的情况下，不做下方的任何动作
- 清除SIE来disable一切中断
- 把pc复制到sepc
- 把当前的模式(user / supervisor)保存到SPP
- 设置scause寄存器来指示产生trap的原因
- 将当前的模式设置为supervisor
- 将stvec的值复制到pc
- 开始执行pc指向的trap handler的代码
  注意CPU并没有切换到kernel页表，也没有切换到kernel栈

trap执行时我们需要更改一些cpu状态，大致流程如下：

- 首先，我们需要保存32个用户寄存器。我们希望执行完trap能恢复到用户程序，并且用户程序无感。
- 保存pc
- 修改mode为supervisor，因为我们需要特权指令。
- 将SATP从用户页表指向内核页表。
- 我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的C函数。

从用户mode到内核，其实增加的权限不多，大概有以下两点：

- 读写SATP寄存器，也就是page table的指针；STVEC，也就是处理trap的内核指令地址；SEPC，保存当发生trap时的程序计数器；SSCRATCH等等。在supervisor mode你可以读写这些寄存器，而用户代码不能做这样的操作。
- 可以使用PTE_U标志位为0的PTE。1的不能访问。

## syscall Trap代码执行流程

以shell中执行write为例。在shell看来只是调用了函数write。

1. shell调用write时，调用的是关联的库函数，(在usys.S),在这个库函数中，先将调用的syscall的号(syscall.h定义)写入a7，执行ECALL指令进行syscall，切换到内核态，执行完后执行ret返回用户态。
2. 执行第一个函数是uservec(trampoline.S)
3. 在汇编函数中跳转到usertrap中(trap.c)
4. 在trap.c中执行了syscall函数。这个函数在表单中找到sys_write函数并执行，执行完后返回到syscall。
5. 调用一个函数叫做usertrapret(trap.c)
6. 调用userset(trampoline.S),在这个函数调用汇编指令返回用户空间。

当user space中发生trap时，会将stvec的值复制到pc，而此时stvec的值是trampoline.S中的uservec，因此跳转到uservec，先保存一些现场的寄存器，恢复kernel栈指针、kernel page table到satp寄存器，再跳转到usertrap(kernel/trap.c)trap handler，然后返回usertrapret(kernel/trap.c)，跳回到kernel/trampoline.S，最后用userret(kernel/trampoline.S)通过sret跳回到user space

RISC-V在trap中不会改变页表，因此user page table必须有对uservec的mapping，uservec是stvec指向的trap vector instruction。uservec要切换satp到kernel页表，同时kernel页表中也要有和user页表中对uservec相同的映射。RISC-V将uservec保存在trampoline页中，并将TRAMPOLINE放在kernel页表和user页表的相同位置处(MAXVA)

当uservec开始时所有的32个寄存器都是trap前代码的值，但是uservec需要对某些寄存器进行修改来设置satp，可以用sscratch和a0的值进行交换，交换之前的sscratch中是指向user process的trapframe的地址，trapframe中预留了保存所有32个寄存器的空间。p->trapframe保存了每个进程的TRAPFRAME的物理空间从而让kernel页表也可以访问该进程的trapframe

当交换完a0和sscratch之后，uservec可以通过a0把所有当前寄存器的值保存到trapframe中。由于当前进程的trapframe已经保存了当前进程的kernel stack、当前CPU的hartid、usertrap的地址、kernel page table的地址等，uservec需要获取这些值，然后切换到kernel pagetable，调用usertrap

usertrap主要是判断trap产生的原因并进行处理，然后返回。因为当前已经在kernel里了，所以这时候如果再发生trap，应该交给kernelvec处理，因此要把stvec切换为kernelvec。如果trap是一个system call，那么syscall将被调用，如果是设备中断，调用devintr，否则就是一个exception，kernel将杀死这个出现错误的进程

回到user space的第一步是调用usertrapret()，这个函数将把stvec指向uservec，从而当回到user space再出现trap的时候可以跳转到uservec，同时设置p->trapframe的一些值为下一次trap作准备，比如设置p->trapframe->kernel_sp = p->kstack + PGSIZE。清除SPP为从而使得调用sret后能够回到user mode。设置回到user space后的program counter为p->trapframe->epc，最后调用跳转到TRAMPOLINE页上的userret回到trampoline.S，加载user page table。userret被userrapret调用返回时a0寄存器中保存了TRAPFRAME，因此可以通过这个TRAPFRAME地址来恢复之前所有寄存器的值(包括a0)，最后把TRAPFRAME保存在sscratch中，用sret回到user space

具体详细步骤看课程。

## Traps from kernel space

当执行kernel code发生CPU trap的时候，stvec是指向kernelvec的汇编代码的。kernelvec将寄存器的值保存在被中断的kernel thread的栈里而不是trapframe里，这样当trap需要切换kernel thread时，再切回来之后还可以从原先的thread栈里找到之前的寄存器值。

保存完寄存器之后，跳转到kerneltrap这个trap handler。kerneltrap可以对设备中断和exception这两种trap进行处理。如果是设备中断，调用devintr进行处理，如果是exception就panic，如果是因为计时器中断，就调用yield让其他kernel thread运行

最后返回到kernelvec中，kernelvec将保存的寄存器值从堆栈中弹出，执行sret，将sepc复制到pc来执行之前被打断的kernel code

# Page faults

## Page Faults Basics
当试图访问PTE_V为0的虚拟地址或user访问PTE_U为0/kernel访问PTE_U为1以及其他违反PTE_W/PTE_R等flag的情况下会出现page faults。Page faults是一个exception，总共有3种page faults：

- load page faults：当load instruction无法翻译虚拟地址时发生
- store page faults：当store instruction无法翻译虚拟地址时发生
- instruction page faults：当一个instruction的地址无法翻译时发生

在xv6中对于exception一律都会将这个进程kill掉，但是实际上可以结合page faults实现一些功能：

- 可以实现copy-on-write fork。在fork时，一般都是将父进程的所有user memory复制到子进程中，但是fork之后一般会直接进行exec，这就会导致复制过来的user memory又被放弃掉。因此改进的思路是：子进程和父进程共享一个物理内存，但是mapping时将PTE_W置零，只有当子进程或者父进程的其中一个进程需要向这个地址写入时产生page fault，此时才会进行copy
- 可以实现lazy allocation。旧的sbrk()申请分配内存，但是申请的这些内存进程很可能不会全部用到，因此改进方案为：当进程调用sbrk()时，将修改p->sz，但是并不实际分配内存，并且将PTE_V置0。当在试图访问这些新的地址时发生page fault再进行物理内存的分配
- paging from disk：当内存没有足够的物理空间时，可以先将数据存储在其他的存储介质（比如硬盘）上，，将该地址的PTE设置为invalid，使其成为一个evicted page。当需要读或者写这个PTE时，产生Page fault，然后在内存上分配一个物理地址，将这个硬盘上的evicted page的内容写入到该内存上，设置PTE为valid并且引用到这个内存物理地址

我们主要关心三个信息当发生了page fault:

- 引起page fault的虚拟地址，或者是触发page fault的源，存放在stval寄存器
- 引起page fault的原因，存放在scause寄存器。该寄存器保存的是trap机制中进入supervisor mode的原因，而page fault使用同样的trap机制。
- 引起page fault时的pc，方便处理完page fault之后重新执行指令。

## Lazy Page allocation

进程调用sbrk()时，修改p->sz但是不分配内存，并且将PTE_V置0，在kernel/trap.c中的usertrap()中处理。
我们通过判断出错的虚拟地址在(stval寄存器)是否小于p->sz(now p->sz has been modified),如果小于说明需要分配内存，否则是错误地址。即下图中的stack地址。
![alt text](images/image-2.png)
相比于eager allocation, lazy allocation将分配内存放在了实际需要用到时，但是这个时候会发生trap，一般是store指令，此时需要从user to kernel，从上一节可以看到，发生trap需要store多次，因此会产生额外的overhead。

## Zero Fill On Demand

用户程序的地址空间中，除了有text和data区，在他们两个上边还有一个bss区，这个bss区用来存放未被初始化或者初始化为0的全局或者静态变量，data用来存放已初始化的全局变量和静态变量。
bss区可能有很多个为0的page，我们可以优化，只分配一个page，set 0，将所有虚拟地址空间的为0的page映射到这个page，程序启动时可以节省很多物理内存的分配。这个物理page应该是只读的。
如果尝试对bss中的一个page进行更改，那么需要重新分配一个物理page，修改pte，可读可写。
有点类似于lazy page allocation, 同样也会有额外的overhead.

## Copy on Write Fork
在fork时，子进程不创建新的page，而是共享父进程的page，但是需要注意的是，出于对隔离性的考虑，我们需要将page都设置为只读，当父进程或者子进程需要写时触发page fault，重新分配一个新的page，copy出错的page，mapping new page to 子进程，将新的和出错的page都设置为可读写。
当发生page fault时如何判断是 Copy on write呢？需要用到pte中的另一个标志未RSW。
另外，因为父进程和子进程都指向同一个物理page，甚至子进程的子进程仍然指向他，那么在释放的时候需要格外注意重复释放问题。因此需要引入新的元数据信息来存放对物理page的引用计数，当释放一个虚拟page，将计数器-1，计数器为0释放物理page。

## Demand Paging

exec()系统调用，需要重新加载内存并以eager的方式将他们加载到pagetable，但是这是不必要的。我们可以为text等分配好地址段，但是不分配物理page。
程序从地址0开始，在此处发生第一个page fault, 这些page是on-demand page, 我们需要将page对应的程序文件加载进内存，再将内存page映射到page table。
有一种情况，如果二进制文件太大或者data等太大，那么内存不够用，一种选择是撤回page(evict page), 此时使用LRU算法撤回，diary标志，我们撤回non-diary page，以及access位，未被访问的page会被直接撤回。

## Memory Mapped Files

将完整或者部分文件加载到内存中，这样就可以通过load、store操作文件。
操作系统提供mmap(va, len, protection, flags, fd, offset)系统调用, prot是write/read，flags表示进程独享还是共享。内核将从offset位置开始的文件读入内存，修改文件后使用unmap将diary blocks写回。
使用lazy机制，先记录这个PTE属于这个文件描述符。相应的信息通常在VMA结构体中保存，VMA全称是Virtual Memory Area。例如对于这里的文件f，会有一个VMA，在VMA中会记录文件描述符，偏移量等等，这些信息用来表示对应的内存虚拟地址的实际内容在哪，当我们得到一个位于VMA地址范围的page fault时，内核可以从磁盘中读数据，并加载到内存中。