- [Lec04 Page tables](#lec04-page-tables)
  - [Page table](#page-table)
  - [页表缓存（Translation Lookaside Buffer）](#页表缓存translation-lookaside-buffer)
  - [Kernel Page Table](#kernel-page-table)
  - [Code](#code)

# Lec04 Page tables
## Page table
内存管理单元（MMU，，emory Management Unit）将虚拟地址（virtual address简称va）翻译为物理内存（简称pa）。mmu有表单，保存在内存中，mmu访问内存完成翻译。
不为每一个地址创建一个表单条目，而是为每个页创建一个表单，每次翻译针对一个page，xv6中规定一个页4096字节，也就是2^12字节。
xv6的page table分为三级页表，虚拟地址39位，低12位是offset，对应page大小，实际上用来索引在page中的位置。中间的27位是三级index，剩下的高25位无效。使用高9位索引第一级page directory，directory的一个条目成为PTE(page table entry)，9位用来索引，因此一个directory page有512个条目。每个pte共使用54bits，低10bits是flag，44bits的物理页号（ppn）。高级page directory中的ppn指向低级page directory，最低一级的ppn加上va的offset构成pa。
使用三级页表的好处是节省空间，如果一个进程只是用了一个page，如果不使用三级页表，就需要2^27个pte，现在，只需要1级页表，第0个pte指向二级，二级第0个指向三级，共3*512个条目。
最高级的表单的地址存储在stap寄存器中，切换进程时需要切换stap中的内容，每个进程对应的stap由内核保存。
高级page directory中的44bits ppn，低12bits填0，得到下一级page directory的物理地址。最后一级加上offset得到pa。
每个pte低10bits是flags，包括V，是否有效，如上述例子只使用1个page，那么第一级页表的第0个pte的v置为1其他为0。其他还有r、w、u等。**注意，这些flag声明的是对应的page的权限，而不是pte自己的**
如果pte指向物理地址，那么v和其他权限为如r、w、x等会被设置，指向下一级只设置v。因此可以使用`if ((pte & (PTE_R | PTE_W | PTE_X)) == 0)`判断是否是最后一级页表。
## 页表缓存（Translation Lookaside Buffer）
加载存储数据需要三次访问内存，速度较慢，因此有TLB。第一次访问得到va到pa的映射后存储在tlb中。切换进程需要切换page table，os告诉cpu，tlb不能用了。
## Kernel Page Table
xv6中，在完成了虚拟到物理地址的翻译之后，如果得到的物理地址大于0x80000000会走向DRAM芯片，如果得到的物理地址低于0x80000000会走向不同的I/O设备。地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。cpu中有一个多路选择器来选择指令是走内存还是哪个硬件。
内核的虚拟地址，xv6采用直接映射，即va和pa相同。kernel stack在va中很靠后，在它下面有未映射的Guard page，对应的flag v未设置，防止stack越界，越界报错。kernel stack被映射了两次，在靠后的虚拟地址映射了一次，在PHYSTOP下的Kernel data中又映射了一次，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。
![alt text](images/image.png)
每个进程有一个对应的stack。XV6使用这段free memory来存放用户进程的page table，text和data。如果我们运行了非常多的用户进程，某个时间点我们会耗尽这段内存，这个时候fork或者exec会返回错误。当kernel创建了一个进程，针对这个进程的page table也会从Free memory中分配出来。内核会为用户进程的page table分配几个page，并填入PTE。在某个时间点，当内核运行了这个进程，内核会将进程的根page table的地址加载到SATP中。从那个时间点开始，处理器会使用内核为那个进程构建的虚拟地址空间。
本质上来说the size of kernel va space is same as user's.
## Code
查看main函数，调用的一个函数是kvminit，这个函数会设置好kernel的地址空间。
之后，kvminit函数返回了，在main函数中，我们运行到了kvminithart函数。
```c
void
kvminithart()
{
  w_satp(MAKE_SATP(kernel_pagetable));
  sfence_vma();
}
```
设置了SATP寄存器，kernel_pagetable变量来自于kvminit第一行。所以这里实际上是内核告诉MMU来使用刚刚设置好的page table。在这条指令之前，还不存在可用的page table，所以也就不存在地址翻译。执行完这条指令之后，程序计数器（Program Counter）增加了4。而之后的下一条指令被执行时，程序计数器会被内存中的page table翻译。