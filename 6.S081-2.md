# File system performance and fast crash recovery

主要是看linux中使用的ext3文件系统，ext3是在ext2的基础上加上日志。

所有的log系统基本都需要坚持两个原则：write-ahead rule and freeing rule. 后文称为”两原则“

- write-ahead rule: 一堆写操作具有原子性，文件系统需要将所有的写操作记录在log中，然后才能写到实际位置
- freeing rule: 只有log中一个事务的所有写操作都被写入到实际位置才可清除。

## ext3 file system log format

ext3与xv6类似，首先在内存中有block cache，（write-back cache），其中有些是干净的数据有些是脏的。因为“两原则”，有些cache需要固定，即不可以被写回disk。

ext3的log可以同时存在多个transaction，每个事务维护如下信息：（由此可以看出维护的这些信息是再内存中）

- 序列号
- 该事务修改的block号，这些block号指的是cahce中的，因为修改最初都是在cache中。
- 一系列handle，handle对应syscall，这些系统调用是transaction的一部分，会读写cache中的block。

ext3的磁盘结构也与xv6类似，一个文件系统树，包含inode、目录、文件等，有bitmap block标志每个data block是是否被分配。有log区。

磁盘上的log区：（一段连续的block）

- 最开始是super block，这是log的super block，记录了log中第一个有效的事务的起始位置和序列号，起始位置就是事务在log区中的块号。super block后是存放事务的块。
- 每个事务包含：
  - 一个descriptor block，类似于xv6中的header block。包含log数据对应的实际block号
  - 每个block号的更新数据
  - 最后是一个commit block。
- 多个事务连一起，前一个事务的commit连着下一个的descriptor。
- 为了区分，descriptor会以一个32bit的魔法数字开头。

同一时间只会有一个事务在进行，在内存中，对应的syscall更新cache中的快。当ext3决定结束事务，先开启一个新的事务，然后将完成的事务写入磁盘。log磁盘中有已经完成的事务，logging系统在后台将完成的log写到实际块。log是循环的，用到最后会回到开始。

## ext3如何提升性能

三种方式：

- 异步系统调用。syscall写入磁盘之前就返回了，syscall只更新cache，不等待写disk。不过可能等待read disk
- 批量执行，将多个syscall打包成一个事务
- 并发

---

异步系统调用：

syscall能够快速返回，而xv6需要等待写磁盘。使得I/O可以并行运算，syscall返回，文件系统在后台执行写disk。磁盘操作和syscall并行。

同时让大批量执行容易。

缺点是，同步问题。对文件的syscall已经返回，用户收到返回，但是还没有写入disk，这时crash，那么重启后可能没有了。尤其对数据库文本编辑器这些应用程序。

文件系统提供了fsync系统调用，接受一个fd，所有数据写入disk后才返回，有时也叫flush。

---

批量执行：

一段时间后开启一个事务，在此期间所有的syscall都在这个事务里。好处有很多：

- 在多个syscall之间分摊了事务的固有损耗，包括写事务的descriptor和commit。在disk查找log位置也很费时。
- 多个系统调用可能用到同一个块，更容易触发write absorption。简单说就是空间局部性。
- 磁盘调度。log中是连续分区，disk写连续分区总是快的。而对于write to home，一次送给disk多个块，那么磁盘可以按某种算法调度，以减少寻道时间。

---

并发：

ext3允许多个syscall同时执行。

可以有多个不同状态的事务同时存在：

- 一个open transaction
- 若干个正在commiting to log
- writing to home
- freeing

---

如果一个block正在commiting to log, 此时另一个事务中要写这个块怎么办？

ext3结束当前事务前，会拷贝用到的block cache，然后commit的是副本，这里为了效率使用cow。

## ext3 syscall format

系统调用需要声明对写操作的开始和结束。syscall先调用start函数，每个syscall call start()后，获得一个handle唯一标识了当前的syscall，然后syscall需要读写block，通过get(handle，blockno)获得block在buffer中的缓存，同时告诉handle这个block需要被读或写，如果操作多个block那么会执行多次。get函数告诉logging，这个block是handle对应的事务的一部分。然后修改buffer中的block。此syscall结束时调用stop(handle), 文件系统需要直到sysall属于哪个事务，因此需要将handle传入。

只有事务中所有的syscall都结束，才能commit。事务需要记录所有开始的handle ，stop只是告诉他结束了一个syscall。

## ext3 事务commit步骤

1. 阻止新的syscall，（会损害性能）
2. 等待包含在事务中的syscall结束。
3. 所有的syscall结束，开始一个新的事务。
4. 更新descriptor block
5. 将被修改的block从buffer写入log
6. 等待写log结束
7. 写入commit block
8. 等待commit block写入结束。这个就是commit point
9. write to home
10. reuse log

重用问题，如果log不够用，那么需要其他事务log的清除，如果没有足够空间开commit，不能开启一个新的事务。

为什么阻止新的syscall？考虑下面的情况：

如果事务T1只有一个create系统调用，创建文件x，然后事务commit，等待create完成。此时开一个T2，unlink(y), T1的create发现y释放的inode假设是17并用了它，然后T1写入log，在T2关闭前crash，恢复时看到T1，那么将T1恢复，也就是说inode17是x，但是T2并没有写入磁盘，所以inode17没有被释放，y也是17，那么两个文件用了一个inode。

## ext3文件系统恢复过程

从super block找到开始的事务，然后扫描已经commit的事务，直到找到最后一个，后边的可能是一个由开始块但是没有commit块的，忽略，然后从头开始恢复。恢复期间不可以执行任何程序。

如果一个数据块以魔法数字开头，在descriptor中有一个bit记录该块以魔法数字开头，然后将data中的前32bit置为0，在write to home时恢复，所以只有descriptor以魔法数字开头。

## other

有一个内核线程（实际可能有多个）来处理disk的log。

commit中也有事务号，所以不会出现一个新事物在最后写commit时crash，但是又恰好是被清除事务的commit，导致恢复程序认错。

在写descriptor时就已经知道了这个事务有多少个block。

所以这个commit块可以不用，可以像xv6一样放在开始那个块。实际上et4这么做了。他同时写data block和commit，磁盘可以无需执行写，有可能先写了commit但是没有data，所以ext4加入了校验。

ext3有3中写入data block的方法。journaled data ordered data and writeback. 在配置ext3文件系统时需要告诉linux要哪种。

- journaled data: 就是写两遍。先写到log，在写到data
- ordered data：最常见的，log中只写元数据，data直接写到home。ext3写完data后再commit，这样如果写操作将元数据和commit写到log但是data还没有写完，然后crash，那么你那个data是错误数据。但是后commit就不会有问题。

# Virtual memory for application

## 特性

os内核使用了灵活的page table，例如lazy allocation and cow。应用程序也可以从这些灵活的虚拟内存中获益。例如垃圾回收机制和共享虚拟内存(mmap)

所有这些用户程序需要以下特性

- 需要trap让发生在内核中的page fault传播到用户空间，然后再用户空间的handler处理对应的页中断。
- Prot1，降低一个page的accessability，也就是page的读写权限。除了prot1，还有protN，因为prot1需要一次需要修改标志未，再清除快表，如果protN只是单纯的多次调用prot1，那么会多次修改快表，所以有protN，只修改一个快表
- Unprot，增加page的权限
- 查看内存page是否是dirty
- map2，使一个应用程序可以在特定的内存空间映射两次。并且这两次可以有不同的权限。

## 相关的系统调用

mmap():

```c
void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
int munmap(void *addr, size_t length);
```

mmap除了以可映射文件还可以映射匿名内存。对应map2

mprotect()：`int mprotect(void *addr, size_t len, int prot);`修改权限。对应特性prot1、protN

sigaction：应用程序设置一旦某个signal发生就调用对应的handler，对应特性trap

## 虚拟内存如何支持应用程序

地址空间包含一些os的数据结构，称为VMAs(virtual memory areas). 每个vma对应一个连续的地址段section。连续地址段的所有page具有相同的权限。

假设一个pte是invalid或只读，你想要写，那么cpu会跳转到trampoline，kernel保存用户程序状态，例如是segfault，应用程序设置了一个handler处理，那么这个事件会传播到用户空间，用过用户空间的upcall在用户空间运行handler，handler运行完返回内核代码，内核恢复执行。

## 垃圾回收

//TODO:GC

# Os organization

## Monolithic kernel

宏内核，传统的操作系统实现方式，是一个完成了很多功能的大的程序。提供强大的抽象。好处是：

- 高度抽象的接口可移植，无论是什么样的存储设备都可以以同样的接口运行。
- 向应用程序隐藏复杂性。例如提供地址空间而不是直接访问MMU硬件。
- 强大的抽象帮助管理共享资源。例如将内存外存交给内核管理。
- 所有的功能都在一个内核程序中，使得他们彼此之间可以互相访问各自的数据结构。
- 内核的所有代码都以完整的硬件权限运行。

缺点：

- 大且复杂。过于复杂的结构很容易产生安全问题。
- 为了通用性功能多而全，但是很多设备可能只使用一小部分。并且通用一般就会更慢。
- 太大反而削弱了某些复杂的抽象能力，内核有许多设计考虑，应用程序必须遵守。
- 可扩展性差。

## Micro kernel

微内核的核心是实现IPC(inter-process communication)以及线程和任务的tiny kernel。微内核只提供进程抽象和通过IPC进程间通信的方式，其他的例如文件系统等都通过用户空间进程实现，kernel只负责进程之间的通信。内核中唯一需要做的就是支持进程/任务/线程以及IPC来传递消息。

IPC这种思想不止在微内核在宏内核等各种OS中都很常见。

可能的优势：

- 代码少，容易优化，容易验证是否安全
- 设计限制更少，给应用程序提供更多的灵活性
- 原本位于内核的很多东西现在位于用户空间，更容易模块化
- 更容易定制化
- OS更健壮，大多数的错误来自驱动，微内核驱动不在内核里
- 可以在微内核运行多个OS

存在的挑战：

- syscall api不好设计，可能内核需要提供一些syscall，但是又不知道例如文件系统等。
- 性能，宏内核文件系统可以和虚拟内存直接交互，但是微内核不行

# Virtual Machine

在硬件之上是HOST空间，存在一个Virtal machine monitor(VMM)或者叫Hypervisor，上面一层是Guest空间，运行OS kernel，GUest也有Supervisor mode and User mode。

在Guest操作系统上运行特权指令会trap到VMM。

## trap and emulate

VMM会为每个虚拟机维护一套虚拟状态信息，主要是特权寄存器，当guest os需要访问特权寄存器那么会trap到VMM，这种风格叫trap and emulate。在guest os中会有两种触发trap的方式，一种是guest usermode syscall，另一种是特权指令。

为什么要有虚拟特权寄存器？假设guest user syscall，此时SCAUSE reg是ECALL，但是guest内核的trap handler需要读这个reg，此时引发另一种trap，那么SCAUSE被改变，但是我们不能然guest os知道。

VMM需要知道guest运行的模式，因此页维护guest os的mode信息，当sret时更新为user mode。还维护了cpuid。

guest中的用户代码，如果是普通指令，直接在硬件上运行。

例如guest user syscall，执行ECALL，这是特权指令，进入VMM，此时VMM发现是user mode执行ECALL，VMM更新一系列的虚拟寄存器，然后将真实的SEPC设置成虚拟的STVEC， 之后VMM调用sret返回，因为真实的SEPC被设置为虚拟的STVEC，所以返回到guest的trap handler。

### trap and emulate---page table

Guest有page table，但是我们不能只是简单的让guest修改SATP reg通过trap进入VMM，然后VMM就设置SATP成guest想要的，因为这会导致guest可以访问任意的内存。所以VMM会为每个虚拟机维护一个映射表，Shadow page table：

* 从Guest Page Table中取出每一条记录，查看gpa。
* 使用VMM中的映射关系，将gpa翻译成hpa。
* 再将gva和hpa存放于Shadow Page Table。

所以guest看到的page table，他会以为那就是正常的page table，但是实际上使用的是VMM维护的shadow page table。

另一种guest与page table交互的方式是修改pte，在riscv中修改了pte并且希望MMU看到，那么需要执行一条特权指令，此时会trap进VMM，VMM负责修改实际的page table。

### trap and emulate---devices

三种策略：

- 模拟真实硬件。guest仍然像与真实硬件交互一样，VMM不映射这些设备对应的内核地址，因此trap进VMM，VMM模拟硬件相应guest。
- 提供虚拟设备。这种情况下，guest知道自己是虚拟的。guest设备驱动中美欧memory mapped reg，而是在内存中有一个命令队列，guest将读写设备的命令写入队列，然后VMM读取。减少了trap，速度更快，但是通用性不如上一个
- 堆真实的设备pass-through，例如网卡，每个guest拥有硬件的一部分。

## 硬件对虚拟机的支持

trap and emulate虚拟机方案有太多的trap，性能不好，而且，这得益于riscv对虚拟机的支持，因为有特权寄存器和特权指令。

硬件自己有虚拟寄存器，在guest mode下使用。intel称为non-root mode. 如果想要创建一个新的虚拟机，在VMM中维护一个结构体VMCS(virtual machine control structure)，存储一些虚拟机的初始信息，VT-x硬件与这个结构体交互。这样普通的特权指令就可以直接在硬件上运行，但是仍然有一些指令会trap到VMM.一个是VMCALL，另一个是定时器中断。意味着一个虚拟机不可以持续占有虚拟机，就像线程不可以持续占有cpu。

VT-x另一个是对page table的支持。intel中类似于SATP的寄存器CR3，guest可以直接加载任何想要的值到CR3，VT-x中存在另一个reg：EPT(extended page table)。当启动一个虚拟机会为他设置一个EPT。CR3将gva翻译成gpa，EPT将gpa变成hpa。

## Dune: Safe User-level Access to Privileged CPU Features

用硬件对虚拟机的支持实现一些linux进程的其他操作。

简单来说就是利用VT-x，将进程当作一个虚拟机，内核中有一个Dune，他管理进程，进程又有自己的guest supervisor mode和uguest user mode。在super下可以访问CR3，当然dune也会控制EPT。

# kernels and hll

## c语言的优缺点

优点：

- c提供了大量的控制，例如可以完全控制内存的分配和释放。
- c几乎没有隐藏的代码，看源码就相当于看机器指令
- 可以直接访问内存
- 很少的依赖。

缺点：

- buffer overruns:数组越界，stack溢出
- use-after-free bugs
- threads sharing dynamic memory
