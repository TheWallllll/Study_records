# File system performance and fast crash recovery

主要是看linux中使用的ext3文件系统，ext3是在ext2的基础上加上日志。

所有的log系统基本都需要坚持两个原则：write-ahead rule and freeing rule. 后文称为”两原则“

- write-ahead rule: 一堆写操作具有原子性，文件系统需要将所有的写操作记录在log中，然后才能写到实际位置
- freeing rule: 只有log中一个事务的所有写操作都被写入到实际位置才可清除。

## ext3 file system log format

ext3与xv6类似，首先在内存中有block cache，（write-back cache），其中有些是干净的数据有些是脏的。因为“两原则”，有些cache需要固定，即不可以被写回disk。

ext3的log可以同时存在多个transaction，每个事务维护如下信息：（由此可以看出维护的这些信息是再内存中）

- 序列号
- 该事务修改的block号，这些block号指的是cahce中的，因为修改最初都是在cache中。
- 一系列handle，handle对应syscall，这些系统调用是transaction的一部分，会读写cache中的block。

ext3的磁盘结构也与xv6类似，一个文件系统树，包含inode、目录、文件等，有bitmap block标志每个data block是是否被分配。有log区。

磁盘上的log区：（一段连续的block）

- 最开始是super block，这是log的super block，记录了log中第一个有效的事务的起始位置和序列号，起始位置就是事务在log区中的块号。super block后是存放事务的块。
- 每个事务包含：
  - 一个descriptor block，类似于xv6中的header block。包含log数据对应的实际block号
  - 每个block号的更新数据
  - 最后是一个commit block。
- 多个事务连一起，前一个事务的commit连着下一个的descriptor。
- 为了区分，descriptor会以一个32bit的魔法数字开头。

同一时间只会有一个事务在进行，在内存中，对应的syscall更新cache中的快。当ext3决定结束事务，先开启一个新的事务，然后将完成的事务写入磁盘。log磁盘中有已经完成的事务，logging系统在后台将完成的log写到实际块。log是循环的，用到最后会回到开始。

## ext3如何提升性能

三种方式：

- 异步系统调用。syscall写入磁盘之前就返回了，syscall只更新cache，不等待写disk。不过可能等待read disk
- 批量执行，将多个syscall打包成一个事务
- 并发

---

异步系统调用：

syscall能够快速返回，而xv6需要等待写磁盘。使得I/O可以并行运算，syscall返回，文件系统在后台执行写disk。磁盘操作和syscall并行。

同时让大批量执行容易。

缺点是，同步问题。对文件的syscall已经返回，用户收到返回，但是还没有写入disk，这时crash，那么重启后可能没有了。尤其对数据库文本编辑器这些应用程序。

文件系统提供了fsync系统调用，接受一个fd，所有数据写入disk后才返回，有时也叫flush。

---

批量执行：

一段时间后开启一个事务，在此期间所有的syscall都在这个事务里。好处有很多：

- 在多个syscall之间分摊了事务的固有损耗，包括写事务的descriptor和commit。在disk查找log位置也很费时。
- 多个系统调用可能用到同一个块，更容易触发write absorption。简单说就是空间局部性。
- 磁盘调度。log中是连续分区，disk写连续分区总是快的。而对于write to home，一次送给disk多个块，那么磁盘可以按某种算法调度，以减少寻道时间。

---

并发：

ext3允许多个syscall同时执行。

可以有多个不同状态的事务同时存在：

- 一个open transaction
- 若干个正在commiting to log
- writing to home
- freeing

---

如果一个block正在commiting to log, 此时另一个事务中要写这个块怎么办？

ext3结束当前事务前，会拷贝用到的block cache，然后commit的是副本，这里为了效率使用cow。

## ext3 syscall format

系统调用需要声明对写操作的开始和结束。syscall先调用start函数，每个syscall call start()后，获得一个handle唯一标识了当前的syscall，然后syscall需要读写block，通过get(handle，blockno)获得block在buffer中的缓存，同时告诉handle这个block需要被读或写，如果操作多个block那么会执行多次。get函数告诉logging，这个block是handle对应的事务的一部分。然后修改buffer中的block。此syscall结束时调用stop(handle), 文件系统需要直到sysall属于哪个事务，因此需要将handle传入。

只有事务中所有的syscall都结束，才能commit。事务需要记录所有开始的handle ，stop只是告诉他结束了一个syscall。

## ext3 事务commit步骤

1. 阻止新的syscall，（会损害性能）
2. 等待包含在事务中的syscall结束。
3. 所有的syscall结束，开始一个新的事务。
4. 更新descriptor block
5. 将被修改的block从buffer写入log
6. 等待写log结束
7. 写入commit block
8. 等待commit block写入结束。这个就是commit point
9. write to home
10. reuse log

重用问题，如果log不够用，那么需要其他事务log的清除，如果没有足够空间开commit，不能开启一个新的事务。

为什么阻止新的syscall？考虑下面的情况：

如果事务T1只有一个create系统调用，创建文件x，然后事务commit，等待create完成。此时开一个T2，unlink(y), T1的create发现y释放的inode假设是17并用了它，然后T1写入log，在T2关闭前crash，恢复时看到T1，那么将T1恢复，也就是说inode17是x，但是T2并没有写入磁盘，所以inode17没有被释放，y也是17，那么两个文件用了一个inode。

## ext3文件系统恢复过程

从super block找到开始的事务，然后扫描已经commit的事务，直到找到最后一个，后边的可能是一个由开始块但是没有commit块的，忽略，然后从头开始恢复。恢复期间不可以执行任何程序。

如果一个数据块以魔法数字开头，在descriptor中有一个bit记录该块以魔法数字开头，然后将data中的前32bit置为0，在write to home时恢复，所以只有descriptor以魔法数字开头。

## other

有一个内核线程（实际可能有多个）来处理disk的log。

commit中也有事务号，所以不会出现一个新事物在最后写commit时crash，但是又恰好是被清除事务的commit，导致恢复程序认错。

在写descriptor时就已经知道了这个事务有多少个block。

所以这个commit块可以不用，可以像xv6一样放在开始那个块。实际上et4这么做了。他同时写data block和commit，磁盘可以无需执行写，有可能先写了commit但是没有data，所以ext4加入了校验。

ext3有3中写入data block的方法。journaled data ordered data and writeback. 在配置ext3文件系统时需要告诉linux要哪种。

- journaled data: 就是写两遍。先写到log，在写到data
- ordered data：最常见的，log中只写元数据，data直接写到home。ext3写完data后再commit，这样如果写操作将元数据和commit写到log但是data还没有写完，然后crash，那么你那个data是错误数据。但是后commit就不会有问题。
